use Steep::Diagnostic::Ruby::template

module Steep
  class Project
    class DSL
      interface _WithProject
        def project: () -> Project
      end

      module LibraryOptions : _WithProject
        @library_configured: bool

        attr_reader libraries: Array[String]

        attr_reader stdlib_root: Pathname?

        attr_reader core_root: Pathname?

        attr_reader repo_paths: Array[Pathname]

        # Attribute to keep track of collection configuration
        #
        # * `Pathname` means loading the configuration from the path
        # * `nil` means no configuration is given
        # * `false` means rbs-collection is disabled
        #
        attr_reader collection_config_path: Pathname | false | nil

        # Set up stdlib paths
        #
        def stdlib_path: (core_root: String, stdlib_root: String) -> void

        # Add repository paths
        #
        def repo_path: (*String paths) -> void

        # Set the `rbs_collection.yaml` path
        #
        def collection_config: (Pathname path) -> void

        # Disable `rbs collection`
        #
        def disable_collection: () -> void

        # Add library
        def library: (*String args) -> void

        def to_library_options: () -> Options

        def library_configured?: () -> bool
      end

      class TargetDSL
        attr_reader name: Symbol

        attr_reader sources: Array[String]

        attr_reader signatures: Array[String]

        attr_reader ignored_sources: Array[String]

        attr_reader unreferenced: bool

        include LibraryOptions

        attr_reader code_diagnostics_config: untyped

        attr_reader project: Project

        def initialize: (Symbol name, ?sources: Array[String], ?libraries: Array[String], ?signatures: Array[String], ?ignored_sources: Array[String], ?repo_paths: Array[Pathname], ?code_diagnostics_config: Diagnostic::Ruby::template, project: Project, ?collection_config_path: Pathname?) -> void

        def initialize_copy: (instance other) -> void

        def check: (*String args) -> void

        def ignore: (*String args) -> void

        def signature: (*String args) -> void

        # Configure the code diagnostics printing setup.
        #
        # Yields a hash, and the update the hash in the block.
        #
        # ```rb
        # D = Steep::Diagnostic
        #
        # configure_code_diagnostics do |hash|
        #   # Assign one of :error, :warning, :information, :hint or :nil to error classes.
        #   hash[D::Ruby::UnexpectedPositionalArgument] = :error
        # end
        # ```
        #
        # Passing a hash is also allowed.
        #
        # ```rb
        # D = Steep::Diagnostic
        #
        # configure_code_diagnostics(D::Ruby.lenient)
        # configure_code_diagnostics(D::Ruby.strict) do |config|
        #   config[D::Ruby::NoMethod] = nil
        # end
        # ```
        #
        def configure_code_diagnostics: (template hash) ?{ (template) -> void }-> void
                                      | () { (template) -> void }-> void

        # Mark the target is not referenced from other targets
        #
        # Use this for test targets so that editing files in this target doesn't involve type checking other targets.
        #
        def unreferenced!: (?bool) -> void
      end

      attr_reader project: Project

      def initialize: (project: Project) -> void

      def self.parse: (Project project, String code, ?filename: String) -> void

      def self.eval: (Project project) { () [self: DSL] -> void } -> void

      include LibraryOptions

      def target: (Symbol name) ?{ (TargetDSL) [self: TargetDSL] -> void } -> void
    end
  end
end

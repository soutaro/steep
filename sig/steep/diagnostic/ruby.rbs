use Parser::AST::Node

module Steep
  module Diagnostic
    module Ruby
      type location = Parser::Source::Range | RBS::Location[untyped, untyped]

      class Base
        include Helper

        attr_reader node: Parser::AST::Node?

        attr_reader location: location?

        def initialize: (node: Parser::AST::Node?, ?location: location?) -> void

        def header_line: () -> String

        def detail_lines: () -> String?

        def diagnostic_code: () -> ::String
      end

      interface _DiagnosticWithResult
        def result: () -> Subtyping::Result::Base
      end

      module ResultPrinter : _DiagnosticWithResult
        def relation_message: (Subtyping::Relation[untyped] relation) -> String?

        def detail_lines: () -> String?
      end

      # An assignment has a right hand side value that has an incompatible type to the type of the left hand side.
      #
      # ### Ruby code
      #
      # ```ruby
      # # @type var x: Integer
      # x = "string"
      # ```
      #
      # ### Diagnostic
      #
      # ```
      # test.rb:2:0: [error] Cannot assign a value of type `::String` to a variable of type `::Integer`
      # │   ::String <: ::Integer
      # │     ::Object <: ::Integer
      # │       ::BasicObject <: ::Integer
      # │
      # │ Diagnostic ID: Ruby::IncompatibleAssignment
      # │
      # └ x = "string"
      #   ~~~~~~~~~~~~
      # ```
      #
      %a{diagnostic-class} class IncompatibleAssignment < Base
        attr_reader lhs_type: AST::Types::t

        attr_reader rhs_type: AST::Types::t

        attr_reader result: Subtyping::Result::Base

        include ResultPrinter

        def initialize: (node: Parser::AST::Node, lhs_type: AST::Types::t, rhs_type: AST::Types::t, result: Subtyping::Result::Base) -> void

        def header_line: () -> ::String
      end

      # A method call has an extra positional argument.
      #
      # ### RBS
      #
      # ```rbs
      # class Foo
      #   def foo: (untyped) -> void
      # end
      # ```
      #
      # ### Ruby code
      #
      # ```ruby
      # Foo.new.foo(1, 2)
      # ```
      #
      # ### Diagnostic
      #
      # ```
      # test.rb:7:15: [error] Unexpected positional argument
      # │ Diagnostic ID: Ruby::UnexpectedPositionalArgument
      # │
      # └ Foo.new.foo(1, 2)
      #                  ~
      # ```
      #
      %a{diagnostic-class} class UnexpectedPositionalArgument < Base
        # Node of argument
        attr_reader node (): Parser::AST::Node

        attr_reader params: Interface::Function::Params

        def initialize: (node: Parser::AST::Node, params: Interface::Function::Params) -> void

        def header_line: () -> String
      end

      # An method call needs more positional arguments.
      #
      # ### RBS
      #
      # ```ruby
      # class Foo
      #   def foo: (a, b) -> void
      # end
      # ```
      #
      # ### Ruby code
      #
      # ```ruby
      # Foo.new.foo(1)
      # ```
      #
      # ### Diagnostic
      #
      # ```
      # lib/test.rb:1:8: [error] More positional arguments are required
      # │ Diagnostic ID: Ruby::InsufficientPositionalArguments
      # │
      # └ Foo.new.foo(1)
      #           ~~~~~~
      # ```
      #
      %a{diagnostic-class} class InsufficientPositionalArguments < Base
        # Send/csend node for method calls without blocks
        # block/numblock node for method calls with blocks
        attr_reader node (): Parser::AST::Node

        attr_reader params: Interface::Function::Params

        def initialize: (node: Parser::AST::Node, params: Interface::Function::Params) -> void

        def header_line: () -> String
      end

      # A method call has an extra keyword argument.
      #
      # ### RBS
      #
      # ```rbs
      # class Foo
      #   def foo: (x: untyped) -> void
      # end
      # ```
      #
      # ### Ruby code
      #
      # ```ruby
      # Foo.new.foo(x: 1, y: 2)
      # ```
      #
      # ### Diagnostic
      #
      # ```
      # test.rb:7:18: [error] Unexpected keyword argument
      # │ Diagnostic ID: Ruby::UnexpectedKeywordArgument
      # │
      # └ Foo.new.foo(x: 1, y: 2)
      #                     ~
      # ```
      #
      %a{diagnostic-class} class UnexpectedKeywordArgument < Base
        # pair/kwsplat node
        attr_reader node (): Parser::AST::Node

        attr_reader params: Interface::Function::Params

        def initialize: (node: Parser::AST::Node, params: Interface::Function::Params) -> void

        def header_line: () -> String
      end

      # A method call needs more keyword arguments.
      #
      # ### RBS
      #
      # ```rbs
      # class Foo
      #   def foo: (a: untyped, b: untyped) -> void
      # end
      # ```
      #
      # ### Ruby code
      #
      # ```ruby
      # Foo.new.foo(a: 1)
      # ```
      #
      # ### Diagnostic
      #
      # ```
      # test.rb:5:8: [error] More keyword arguments are required: b
      # │ Diagnostic ID: Ruby::InsufficientKeywordArguments
      # │
      # └ Foo.new.foo(a: 1)
      #           ~~~~~~~~~
      # ```
      #
      %a{diagnostic-class} class InsufficientKeywordArguments < Base
        # Send/csend node for method calls without blocks
        # block/numblock node for method calls with blocks
        attr_reader node (): Parser::AST::Node

        attr_reader params: Interface::Function::Params

        attr_reader missing_keywords: Array[Symbol]

        def initialize: (node: Parser::AST::Node, params: Interface::Function::Params, missing_keywords: Array[Symbol]) -> void

        def header_line: () -> String
      end

      # A method call has type errors, no more specific explanation cannot be reported.
      #
      # ### Ruby code
      #
      # ```ruby
      # 3 + "foo"
      # ```
      #
      # ### Diagnostic
      #
      # ```
      # test.rb:1:0: [error] Cannot find compatible overloading of method `+` of type `::Integer`
      # │ Method types:
      # │   def +: (::Integer) -> ::Integer
      # │        | (::Float) -> ::Float
      # │        | (::Rational) -> ::Rational
      # │        | (::Complex) -> ::Complex
      # │
      # │ Diagnostic ID: Ruby::UnresolvedOverloading
      # │
      # └ 3 + "foo"
      #   ~~~~~~~~~
      # ```
      #
      %a{diagnostic-class} class UnresolvedOverloading < Base
        attr_reader node (): Parser::AST::Node

        attr_reader receiver_type: AST::Types::t

        attr_reader method_name: Symbol

        attr_reader method_types: Array[Interface::MethodType]

        def initialize: (node: Parser::AST::Node, receiver_type: AST::Types::t, method_name: Symbol, method_types: Array[Interface::MethodType]) -> void

        def header_line: () -> String

        def detail_lines: () -> String
      end

      # A method call has an argument that has an incompatible type to the type of the parameter.
      #
      # ### Ruby code
      #
      # ```ruby
      # '1' + 1
      # ```
      #
      # ### Diagnostic
      #
      # ```
      # test.rb:1:6: [error] Cannot pass a value of type `::Integer` as an argument of type `::string`
      # │   ::Integer <: ::string
      # │     ::Integer <: (::String | ::_ToStr)
      # │       ::Integer <: ::String
      # │         ::Numeric <: ::String
      # │           ::Object <: ::String
      # │             ::BasicObject <: ::String
      # │
      # │ Diagnostic ID: Ruby::ArgumentTypeMismatch
      # │
      # └ '1' + 1
      #         ~
      # ```
      #
      %a{diagnostic-class} class ArgumentTypeMismatch < Base
        attr_reader node (): Parser::AST::Node

        attr_reader expected: AST::Types::t

        attr_reader actual: AST::Types::t

        attr_reader result: Subtyping::Result::t

        include ResultPrinter

        def initialize: (node: Parser::AST::Node, expected: AST::Types::t, actual: AST::Types::t, result: Subtyping::Result::t) -> void

        def header_line: () -> ::String
      end

      # A method call calls a method that is not defined on the receiver.
      #
      # ### Ruby code
      #
      # ```ruby
      # "".non_existent_method
      # ```
      #
      # ### Diagnostic
      #
      # ```
      # test.rb:1:3: [error] Type `::String` does not have method `non_existent_method`
      # │ Diagnostic ID: Ruby::NoMethod
      # │
      # └ "".non_existent_method
      #      ~~~~~~~~~~~~~~~~~~~
      # ```
      #
      %a{diagnostic-class} class NoMethod < Base
        attr_reader type: AST::Types::t

        attr_reader method: Symbol

        def initialize: (node: Parser::AST::Node, type: AST::Types::t, method: Symbol) -> void

        def header_line: () -> ::String
      end

      # A `return` statement has a value that has an incompatible type to the return type of the method.
      #
      # ### RBS
      #
      # ```rbs
      # class Foo
      #   def foo: () -> Integer
      # end
      # ```
      #
      # ### Ruby code
      #
      # ```ruby
      # class Foo
      #   def foo
      #     return "string"
      #   end
      # end
      # ```
      #
      # ### Diagnostic
      #
      # ```
      # test.rb:3:2: [error] The method cannot return a value of type `::String` because declared as type `::Integer`
      # │   ::String <: ::Integer
      # │     ::Object <: ::Integer
      # │       ::BasicObject <: ::Integer
      # │
      # │ Diagnostic ID: Ruby::ReturnTypeMismatch
      # │
      # └   return "string"
      #     ~~~~~~~~~~~~~~~
      # ```
      #
      %a{diagnostic-class} class ReturnTypeMismatch < Base
        attr_reader expected: AST::Types::t

        attr_reader actual: AST::Types::t

        attr_reader result: Subtyping::Result::Base

        include ResultPrinter

        def initialize: (node: Parser::AST::Node, expected: AST::Types::t, actual: AST::Types::t, result: Subtyping::Result::Base) -> void

        def header_line: () -> String
      end

      # Setter method, which has a name ending with `=`, returns different type from the method type.
      # This is a special diagnostic for setter methods because the return value is not used with ordinal call syntax.
      #
      # ### RBS
      #
      # ```rbs
      # class Foo
      #   def name=: (String) -> String
      # end
      # ```
      #
      # ### Ruby code
      #
      # ```ruby
      # class Foo
      #   def name=(value)
      #     return if value.empty?
      #     @value = value
      #   end
      # end
      # ```
      #
      # ### Diagnostic
      #
      # ```
      # test.rb:3:4: [information] The setter method `name=` cannot return a value of type `nil` because declared as type `::String`
      # │   nil <: ::String
      # │
      # │ Diagnostic ID: Ruby::SetterReturnTypeMismatch
      # │
      # └     return if value.empty?
      #       ~~~~~~
      # ```
      #
      %a{diagnostic-class} class SetterReturnTypeMismatch < Base
        attr_reader expected: AST::Types::t

        attr_reader actual: AST::Types::t

        attr_reader result: Subtyping::Result::Base

        attr_reader method_name: Symbol

        include ResultPrinter

        def initialize: (node: Parser::AST::Node, method_name: Symbol, expected: AST::Types::t, actual: AST::Types::t, result: Subtyping::Result::Base) -> void

        def header_line: () -> String
      end

      # A method that doesn't accept block is called with a block.
      #
      # ### RBS
      #
      # ```rbs
      # class Foo
      #   def foo: () -> void
      # end
      # ```
      #
      # ### Ruby code
      #
      # ```ruby
      # Foo.new.foo { 123 }
      # ```
      #
      # ### Diagnostic
      #
      # ```
      # test.rb:1:12: [warning] The method cannot be called with a block
      # │ Diagnostic ID: Ruby::UnexpectedBlockGiven
      # │
      # └ Foo.new.foo { 123 }
      #               ~~~~~~~
      # ```
      #
      %a{diagnostic-class} class UnexpectedBlockGiven < Base
        attr_reader method_type: Interface::MethodType

        def initialize: (node: Parser::AST::Node, method_type: Interface::MethodType) -> void

        def header_line: () -> String
      end

      # A method that requires a block is called without a block.
      #
      # ### RBS
      #
      # ```rbs
      # class Foo
      #   def foo: { () -> void } -> void
      # end
      # ```
      #
      # ### Ruby code
      #
      # ```ruby
      # Foo.new.foo
      # ```
      #
      # ### Diagnostic
      #
      # ```
      # lib/test.rb:1:8: [error] The method cannot be called without a block
      # │ Diagnostic ID: Ruby::RequiredBlockMissing
      # │
      # └ Foo.new.foo
      #           ~~~
      # ```
      #
      %a{diagnostic-class} class RequiredBlockMissing < Base
        attr_reader method_type: Interface::MethodType

        def initialize: (node: Parser::AST::Node, method_type: Interface::MethodType) -> void

        def header_line: () -> String
      end

      # A method call passes an object as a block, but the type is incompatible with the method type.
      #
      # ### Ruby code
      #
      # ```ruby
      # multi = ->(x, y) { x * y } #: ^(Integer, Integer) -> Integer
      # [1, 2, 3].map(&multi)
      # ```
      #
      # ### Diagnostic
      #
      # ```
      # test.rb:2:14: [error] Cannot pass a value of type `^(::Integer, ::Integer) -> ::Integer` as a block-pass-argument of type `^(::Integer) -> U(1)`
      # │   ^(::Integer, ::Integer) -> ::Integer <: ^(::Integer) -> U(1)
      # │     (Params are incompatible)
      # │
      # │ Diagnostic ID: Ruby::BlockTypeMismatch
      # │
      # └ [1, 2, 3].map(&multi)
      #                 ~~~~~~
      # ```
      #
      %a{diagnostic-class} class BlockTypeMismatch < Base
        attr_reader expected: AST::Types::t

        attr_reader actual: AST::Types::t

        attr_reader result: Subtyping::Result::Base

        include ResultPrinter

        def initialize: (node: Node, expected: AST::Types::t, actual: AST::Types::t, result: Subtyping::Result::Base) -> void

        def header_line: () -> String
      end

      # The type of the block body is incompatible with the expected type.
      #
      # ### RBS
      #
      # ```rbs
      # class Foo
      #   def foo: () { () -> Integer } -> void
      # end
      # ```
      #
      # ### Ruby code
      #
      # ```ruby
      # Foo.new.foo { "" }
      # ```
      #
      # ### Diagnostic
      #
      # ```
      # lib/test.rb:1:12: [warning] Cannot allow block body have type `::String` because declared as type `::Integer`
      # │   ::String <: ::Integer
      # │     ::Object <: ::Integer
      # │       ::BasicObject <: ::Integer
      # │
      # │ Diagnostic ID: Ruby::BlockBodyTypeMismatch
      # │
      # └ Foo.new.foo { "" }
      #               ~~~~~~
      # ```
      #
      %a{diagnostic-class} class BlockBodyTypeMismatch < Base
        attr_reader expected: AST::Types::t

        attr_reader actual: AST::Types::t

        attr_reader result: Subtyping::Result::Base

        include ResultPrinter

        def initialize: (node: Node, expected: AST::Types::t, actual: AST::Types::t, result: Subtyping::Result::Base) -> void

        def header_line: () -> String
      end

      # A `break` statement has a value that has an incompatible type to the type of the destination.
      #
      # ### Ruby code
      #
      # ```ruby
      # 123.tap { break "" }
      # ```
      #
      # ### Diagnostic
      #
      # ```
      # test.rb:1:10: [error] Cannot break with a value of type `::String` because type `::Integer` is assumed
      # │   ::String <: ::Integer
      # │     ::Object <: ::Integer
      # │       ::BasicObject <: ::Integer
      # │
      # │ Diagnostic ID: Ruby::BreakTypeMismatch
      # │
      # └ 123.tap { break "" }
      #             ~~~~~~~~
      # ```
      #
      %a{diagnostic-class} class BreakTypeMismatch < Base
        attr_reader expected: AST::Types::t

        attr_reader actual: AST::Types::t

        attr_reader result: Subtyping::Result::Base

        include ResultPrinter

        def initialize: (node: Node, expected: AST::Types::t, actual: AST::Types::t, result: Subtyping::Result::Base) -> void

        def header_line: () -> String
      end

      # A `break` statement without a value is used to leave from a block that requires non-nil type.
      #
      # ### Ruby code
      #
      # ```ruby
      # 123.tap { break }
      # ```
      #
      # ### Diagnostic
      #
      # ```
      # test.rb:1:10: [error] Breaking without a value may result an error because a value of type `::Integer` is expected
      # │   nil <: ::Integer
      # │
      # │ Diagnostic ID: Ruby::ImplicitBreakValueMismatch
      # │
      # └ 123.tap { break }
      #             ~~~~~
      # ```
      #
      %a{diagnostic-class} class ImplicitBreakValueMismatch < Base
        attr_reader jump_type: AST::Types::t

        attr_reader result: Subtyping::Result::Base

        include ResultPrinter

        def initialize: (node: Node, jump_type: AST::Types::t, result: Subtyping::Result::Base) -> void

        def header_line: () -> ::String
      end

      # Detected a `break` or `next` statement in invalid context.
      #
      # ### Ruby code
      #
      # ```ruby
      # break
      # ```
      #
      # ### Diagnostic
      #
      # ```
      # test.rb:1:0: [error] Cannot jump from here
      # │ Diagnostic ID: Ruby::UnexpectedJump
      # │
      # └ break
      #   ~~~~~
      # ```
      #
      %a{diagnostic-class} class UnexpectedJump < Base
        def header_line: () -> String
      end

      # A `break` or `next` statement has a value, but the value will be ignored.
      #
      # ### Ruby code
      #
      # ```ruby
      # while true
      #   next 3
      # end
      # ```
      #
      # ### Diagnostic
      #
      # ```
      # test.rb:2:2: [error] The value given to next will be ignored
      # │ Diagnostic ID: Ruby::UnexpectedJumpValue
      # │
      # └   next 3
      #     ~~~~~~
      # ```
      #
      %a{diagnostic-class} class UnexpectedJumpValue < Base
        def header_line: () -> String
      end

      # A class (or module) definition in Ruby code has a module (or class) in RBS.
      #
      # ### Ruby code
      #
      # ```ruby
      # module Object
      # end
      #
      # class Kernel
      # end
      # ```
      #
      # ### Diagnostic
      #
      # ```
      # test.rb:1:7: [error] ::Object is declared as a class in RBS
      # │ Diagnostic ID: Ruby::ClassModuleMismatch
      # │
      # └ module Object
      #          ~~~~~~
      #
      # test.rb:4:6: [error] ::Kernel is declared as a module in RBS
      # │ Diagnostic ID: Ruby::ClassModuleMismatch
      # │
      # └ class Kernel
      #         ~~~~~~
      # ```
      #
      %a{diagnostic-class} class ClassModuleMismatch < Base
        attr_reader name: RBS::TypeName

        def initialize: (node: Parser::AST::Node, name: RBS::TypeName) -> void

        def header_line: () -> ::String
      end

      # The method definition has missing parameters with respect to the RBS definition.
      #
      # ### RBS
      #
      # ```rbs
      # class Foo
      #   def foo: (String, String) -> void
      # end
      # ```
      #
      # ### Ruby code
      #
      # ```ruby
      # class Foo
      #   def foo(x)
      #   end
      # end
      # ```
      #
      # ### Diagnostic
      #
      # ```
      # lib/test.rb:2:9: [error] Method parameters are incompatible with declaration `(::String, ::String) -> void`
      # │ Diagnostic ID: Ruby::MethodArityMismatch
      # │
      # └   def foo(x)
      #            ~~~
      # ```
      #
      %a{diagnostic-class} class MethodArityMismatch < Base
        attr_reader method_type: Interface::MethodType

        def initialize: (node: Node, method_type: Interface::MethodType) -> void

        def header_line: () -> ::String
      end

      # The method definition has an extra parameter with respect to the RBS definition.
      #
      # ### RBS
      #
      # ```rbs
      # class Foo
      #   def foo: (String) -> void
      # end
      # ```
      #
      # ### Ruby code
      #
      # ```ruby
      # class Foo
      #   def foo(x, y)
      #   end
      # end
      # ```
      #
      # ### Diagnostic
      #
      # ```
      # lib/test.rb:2:13: [error] The method parameter is incompatible with the declaration `(::String) -> void`
      # │ Diagnostic ID: Ruby::MethodParameterMismatch
      # │
      # └   def foo(x, y)
      #                ~
      # ```
      #
      %a{diagnostic-class} class MethodParameterMismatch < Base
        attr_reader method_param: TypeInference::MethodParams::PositionalParameter | TypeInference::MethodParams::KeywordParameter

        attr_reader method_type: Interface::MethodType

        def initialize: (method_param: TypeInference::MethodParams::PositionalParameter | TypeInference::MethodParams::KeywordParameter, method_type: Interface::MethodType) -> void

        def header_line: () -> String
      end

      # The method has a parameter with different kind from the RBS definition.
      #
      # ### RBS
      #
      # ```rbs
      # class Foo
      #   def foo: (String?) -> void
      # end
      # ```
      #
      # ### Ruby code
      #
      # ```ruby
      # class Foo
      #   def foo(x=nil)
      #   end
      # end
      # ```
      #
      # ### Diagnostic
      #
      # ```
      # lib/test.rb:2:10: [hint] The method parameter has different kind from the declaration `((::String | nil)) -> void`
      # │ Diagnostic ID: Ruby::DifferentMethodParameterKind
      # │
      # └   def foo(x=nil)
      #             ~~~~~
      # ```
      #
      %a{diagnostic-class} class DifferentMethodParameterKind < Base
        attr_reader method_param: TypeInference::MethodParams::PositionalParameter | TypeInference::MethodParams::KeywordParameter

        attr_reader method_type: Interface::MethodType

        def initialize: (method_param: TypeInference::MethodParams::PositionalParameter | TypeInference::MethodParams::KeywordParameter, method_type: Interface::MethodType) -> void

        def header_line: () -> String
      end

      # **Deprecated** Related to the `@type method` annotation.
      #
      %a{diagnostic-class} class MethodReturnTypeAnnotationMismatch < Base
        attr_reader method_type: untyped

        attr_reader annotation_type: untyped

        attr_reader result: untyped

        include ResultPrinter

        def initialize: (node: untyped, method_type: untyped, annotation_type: untyped, result: untyped) -> void

        def header_line: () -> ::String
      end

      # The type of the method body has different type from the RBS definition.
      #
      # ### RBS
      #
      # ```rbs
      # class Foo
      #   def foo: () -> String
      # end
      # ```
      #
      # ### Ruby code
      #
      # ```ruby
      # class Foo
      #   def foo = 123
      # end
      # ```
      #
      # ### Diagnostic
      #
      # ```
      # lib/test.rb:2:6: [error] Cannot allow method body have type `::Integer` because declared as type `::String`
      # │   ::Integer <: ::String
      # │     ::Numeric <: ::String
      # │       ::Object <: ::String
      # │         ::BasicObject <: ::String
      # │
      # │ Diagnostic ID: Ruby::MethodBodyTypeMismatch
      # │
      # └   def foo = 123
      #         ~~~
      # ```
      #
      %a{diagnostic-class} class MethodBodyTypeMismatch < Base
        attr_reader expected: AST::Types::t

        attr_reader actual: AST::Types::t

        attr_reader result: Subtyping::Result::Base

        include ResultPrinter

        def initialize: (node: Node, expected: AST::Types::t, actual: AST::Types::t, result: Subtyping::Result::Base) -> void

        def header_line: () -> String
      end

      # Setter method, which has a name ending with `=`, has different type from the method type.
      #
      # This is a special diagnostic for setter methods because the return value is not used with ordinal call syntax.
      #
      # ### RBS
      #
      # ### Ruby code
      #
      # ```ruby
      # class Foo
      #   # Assume `name=` has method type of `(String) -> String`
      #   def name=(value)
      #     @value = value
      #     value.strip!
      #   end
      # end
      # ```
      #
      # ### Diagnostic
      #
      # ```
      # lib/test.rb:2:6: [information] Setter method `name=` cannot have type `(::String | nil)` because declared as type `::String`
      # │   (::String | nil) <: ::String
      # │     nil <: ::String
      # │
      # │ Diagnostic ID: Ruby::SetterBodyTypeMismatch
      # │
      # └   def name=(value)
      #         ~~~~~
      # ```
      #
      %a{diagnostic-class} class SetterBodyTypeMismatch < Base
        attr_reader expected: AST::Types::t

        attr_reader actual: AST::Types::t

        attr_reader result: Subtyping::Result::Base

        attr_reader method_name: Symbol

        include ResultPrinter

        def initialize: (node: Parser::AST::Node & Parser::AST::_DefNode, expected: AST::Types::t, actual: AST::Types::t, result: Subtyping::Result::Base, method_name: Symbol) -> void

        def header_line: () -> String
      end

      # A method definition without block has `yield` syntax.
      #
      # ### RBS
      #
      # ```rbs
      # class Foo
      #   def foo: () -> void
      # end
      # ```
      #
      # ### Ruby code
      #
      # ```ruby
      # class Foo
      #   def foo
      #     yield
      #   end
      # end
      # ```
      #
      # ### Diagnostic
      #
      # ```
      # lib/test.rb:3:4: [hint] Cannot detect the type of the expression
      # │ Diagnostic ID: Ruby::FallbackAny
      # │
      # └     yield
      #       ~~~~~
      # ```
      #
      %a{diagnostic-class} class UnexpectedYield < Base
        def header_line: () -> String
      end

      # A method definition has `super` syntax while no super method is defined in RBS.
      #
      # ### RBS
      #
      # ```rbs
      # class Foo
      #   def foo: () -> void
      # end
      # ```
      #
      # ### Ruby code
      #
      # ```ruby
      # class Foo
      #   def foo = super
      # end
      # ```
      #
      # ### Diagnostic
      #
      # ```
      # lib/test.rb:2:12: [information] No superclass method `foo` defined
      # │ Diagnostic ID: Ruby::UnexpectedSuper
      # │
      # └   def foo = super
      #               ~~~~~
      # ```
      #
      %a{diagnostic-class} class UnexpectedSuper < Base
        attr_reader method: Symbol?

        def initialize: (node: Parser::AST::Node, method: Symbol?) -> void

        def header_line: () -> ::String
      end

      # The class/module definition doesn't have a `def` syntax for the method.
      #
      # ### RBS
      #
      # ```rbs
      # class Foo
      #   def foo: () -> String
      # end
      # ```
      #
      # ### Ruby code
      #
      # ```ruby
      # class Foo
      #   attr_reader :foo
      # end
      # ```
      #
      # ### Diagnostic
      #
      # ```
      # lib/test.rb:1:6: [hint] Cannot find implementation of method `::Foo#foo`
      # │ Diagnostic ID: Ruby::MethodDefinitionMissing
      # │
      # └ class Foo
      #         ~~~
      # ```
      #
      %a{diagnostic-class} class MethodDefinitionMissing < Base
        type kind = :instance | :module

        attr_reader module_name: RBS::TypeName

        attr_reader kind: kind

        attr_reader missing_method: Symbol

        def initialize: (node: Node, module_name: RBS::TypeName, kind: kind, missing_method: Symbol) -> void

        def header_line: () -> String
      end

      # A `@dynamic` annotation has unknown method name.
      #
      # Note that this diagnostic emits only if the class definition in RBS has method definitions.
      #
      # ### RBS
      #
      # ```rbs
      # class Foo
      #   def foo: () -> void
      # end
      # ```
      #
      # ### Ruby code
      #
      # ```ruby
      # class Foo
      #   # @dynamic foo, bar
      # end
      # ```
      #
      # ### Diagnostic
      #
      # ```
      # lib/test.rb:1:6: [error] @dynamic annotation contains unknown method name `bar`
      # │ Diagnostic ID: Ruby::UnexpectedDynamicMethod
      # │
      # └ class Foo
      #         ~~~
      # ```
      #
      %a{diagnostic-class} class UnexpectedDynamicMethod < Base
        attr_reader module_name: untyped

        attr_reader method_name: untyped

        def initialize: (node: untyped, module_name: untyped, method_name: untyped) -> void

        def header_line: () -> ::String
      end

      # A constant is not defined in the RBS definition.
      #
      # ### Ruby code
      #
      # ```ruby
      # FOO
      # ```
      #
      # ### Diagnostic
      #
      # ```
      # test.rb:1:0: [error] Cannot find the declaration of constant: `FOO`
      # │ Diagnostic ID: Ruby::UnknownConstant
      # │
      # └ FOO
      #   ~~~
      # ```
      #
      %a{diagnostic-class} class UnknownConstant < Base
        attr_reader name: Symbol

        attr_reader kind: :constant | :class | :module

        def initialize: (node: Node, name: Symbol) -> void

        def class!: () -> self

        def module!: () -> self

        def header_line: () -> String
      end

      # An instance variable is not defined in RBS definition.
      #
      # ### Ruby code
      #
      # ```ruby
      # class Foo
      #   def foo
      #     @foo = 'foo'
      #   end
      # end
      # ```
      #
      # ### Diagnostic
      #
      # ```
      # test.rb:3:4: [error] Cannot find the declaration of instance variable: `@foo`
      # │ Diagnostic ID: Ruby::UnknownInstanceVariable
      # │
      # └     @foo = 'foo'
      #       ~~~~
      # ```
      #
      %a{diagnostic-class} class UnknownInstanceVariable < Base
        attr_reader name: Symbol

        def initialize: (node: Parser::AST::Node, name: Symbol) -> void

        def header_line: () -> ::String
      end

      # Short explanation ending with `.`
      #
      # ### Ruby code
      #
      # ```ruby
      # $foo
      # ```
      #
      # ### Diagnostic
      #
      # ```
      # test.rb:1:0: [error] Cannot find the declaration of global variable: `$foo`
      # │ Diagnostic ID: Ruby::UnknownGlobalVariable
      # │
      # └ $foo
      #   ~~~~
      # ```
      #
      %a{diagnostic-class} class UnknownGlobalVariable < Base
        attr_reader name: Symbol

        def initialize: (node: Node, name: Symbol) -> void

        def header_line: () -> ::String
      end

      # Unable to determine the type of an expression for any reason.
      #
      # ### Ruby code
      #
      # ```ruby
      # @foo
      # ```
      #
      # ### Diagnostic
      #
      # ```
      # lib/test.rb:1:0: [error] Cannot detect the type of the expression
      # │ Diagnostic ID: Ruby::FallbackAny
      # │
      # └ @foo
      #   ~~~~
      # ```
      #
      %a{diagnostic-class} class FallbackAny < Base
        def initialize: (node: Node) -> void

        def header_line: () -> String
      end

      # Failed to solve constraint collected from a method call typing.
      #
      %a{diagnostic-class} class UnsatisfiableConstraint < Base
        attr_reader method_type: Interface::MethodType

        attr_reader var: Symbol

        attr_reader sub_type: AST::Types::t

        attr_reader super_type: AST::Types::t

        attr_reader result: Subtyping::Result::Base

        def initialize: (node: Node, method_type: Interface::MethodType, var: Symbol, sub_type: AST::Types::t, super_type: AST::Types::t, result: Subtyping::Result::Base) -> void

        include ResultPrinter

        def header_line: () -> String
      end

      # Detected a branch local annotation is incompatible with outer context.
      #
      # ### Ruby code
      #
      # ```ruby
      # a = [1,2,3]
      #
      # if _ = 1
      #   # @type var a: String
      #   a + ""
      # end
      # ```
      #
      # ### Diagnostic
      #
      # ```
      # test.rb:5:2: [error] Type annotation about `a` is incompatible since ::String <: ::Array[::Integer] doesn't hold
      # │   ::String <: ::Array[::Integer]
      # │     ::Object <: ::Array[::Integer]
      # │       ::BasicObject <: ::Array[::Integer]
      # │
      # │ Diagnostic ID: Ruby::IncompatibleAnnotation
      # │
      # └   a + ""
      #     ~~~~~~
      # ```
      #
      %a{diagnostic-class} class IncompatibleAnnotation < Base
        attr_reader result: Subtyping::Result::Base

        attr_reader relation: Subtyping::Relation[untyped]

        attr_reader var_name: Symbol

        def initialize: (node: Parser::AST::Node, var_name: Symbol, result: Subtyping::Result::Base, relation: Subtyping::Relation[untyped]) -> void

        include ResultPrinter

        def header_line: () -> String
      end

      # A conditional always/never hold.
      #
      # ### Ruby code
      #
      # ```ruby
      # if false
      #   1
      # end
      # ```
      #
      # ### Diagnostic
      #
      # ```
      # test.rb:1:0: [error] The branch is unreachable
      # │ Diagnostic ID: Ruby::UnreachableBranch
      # │
      # └ if false
      #   ~~
      # ```
      #
      %a{diagnostic-class} class UnreachableBranch < Base
        def header_line: () -> String
      end

      # A branch has a type other than `bot`, but unreachable.
      #
      # This diagnostic skips the `bot` branch because we often have `else` branch to make the code defensive.
      #
      # ### Ruby code
      #
      # ```ruby
      # x = 1
      #
      # case x
      # when Integer
      #   "one"
      # when String
      #   "two"
      # when Symbol
      #   raise "Unexpected value"
      # end
      # ```
      #
      # ### Diagnostic
      #
      # ```
      # test.rb:5:0: [error] The branch may evaluate to a value of `::String` but unreachable
      # │ Diagnostic ID: Ruby::UnreachableValueBranch
      # │
      # └ when String
      #   ~~~~
      # ```
      #
      %a{diagnostic-class} class UnreachableValueBranch < Base
        attr_reader type: AST::Types::t

        def initialize: (node: Parser::AST::Node, type: AST::Types::t, ?location: location) -> void

        def header_line: () -> String
      end

      # The block parameter has non-proc type.
      #
      # ### Ruby code
      #
      # ```ruby
      # -> (&block) do
      #   # @type var block: Integer
      # end
      # ```
      #
      # ### Diagnostic
      #
      # ```
      # test.rb:1:4: [error] Proc type is expected but `::Integer` is specified
      # │ Diagnostic ID: Ruby::ProcTypeExpected
      # │
      # └ -> (&block) do
      #       ~~~~~~
      # ```
      #
      %a{diagnostic-class} class ProcTypeExpected < Base
        attr_reader type: AST::Types::t

        def initialize: (node: Node, type: AST::Types::t) -> void

        def header_line: () -> String
      end

      # The `#to_ary` of RHS of multiple assignment is called, but returns not tuple nor Array.
      #
      # ### RBS
      #
      # ```rbs
      # class Foo
      #   def to_ary: () -> Integer
      # end
      # ```
      #
      # ### Ruby code
      #
      # ```ruby
      # a, b = Foo.new()
      # ```
      #
      # ### Diagnostic
      #
      # ```
      # lib/test.rb:1:6: [error] Cannot convert `::Foo` to Array or tuple (`#to_ary` returns `::Integer`)
      # │ Diagnostic ID: Ruby::MultipleAssignmentConversionError
      # │
      # └ a,b = Foo.new
      #         ~~~~~~~
      # ```
      #
      %a{diagnostic-class} class MultipleAssignmentConversionError < Base
        attr_reader original_type: AST::Types::t

        attr_reader returned_type: AST::Types::t

        def initialize: (node: Parser::AST::Node, original_type: AST::Types::t, returned_type: AST::Types::t) -> void

        def header_line: () -> ::String
      end

      # The syntax is not currently supported by Steep.
      #
      %a{diagnostic-class} class UnsupportedSyntax < Base
        attr_reader message: String

        def initialize: (node: Node, ?message: String?) -> void

        def header_line: () -> String
      end

      # Unexpected error is raised during type checking. Maybe a bug.
      #
      %a{diagnostic-class} class UnexpectedError < Base
        attr_reader error: Exception

        def initialize: (node: Parser::AST::Node, error: Exception) -> void

        def header_line: () -> String
      end

      # The Ruby code has a syntax error.
      #
      # ### Ruby code
      #
      # ```ruby
      # if x == 1
      #   puts "Hello"
      # ```
      #
      # ### Diagnostic
      #
      # ```
      # test.rb:2:14: [error] SyntaxError: unexpected token $end
      # │ Diagnostic ID: Ruby::SyntaxError
      # │
      # └   puts "Hello"
      # ```
      #
      %a{diagnostic-class} class SyntaxError < Base
        attr_reader message: String

        def initialize: (message: String, location: RBS::Location[untyped, untyped]) -> void

        def header_line: () -> String
      end

      # The type assertion cannot hold.
      #
      # ### Ruby code
      #
      # ```ruby
      # array = [] #: Array[Integer]
      # hash = array #: Hash[Symbol, String]
      # ```
      #
      # ### Diagnostic
      #
      # ```
      # test.rb:2:7: [error] Assertion cannot hold: no relationship between inferred type (`::Array[::Integer]`) and asserted type (`::Hash[::Symbol, ::String]`)
      # │ Diagnostic ID: Ruby::FalseAssertion
      # │
      # └ hash = array #: Hash[Symbol, String]
      #          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      # ```
      #
      %a{diagnostic-class} class FalseAssertion < Base
        attr_reader assertion_type: AST::Types::t

        attr_reader node_type: AST::Types::t

        def initialize: (node: Parser::AST::Node, assertion_type: AST::Types::t, node_type: AST::Types::t) -> void

        def header_line: () -> String
      end

      # An extra type application is given to a method call.
      #
      # ### RBS
      #
      # ```rbs
      # class Foo
      #   def foo: [T] (T) -> T
      # end
      # ```
      #
      # ### Ruby code
      #
      # ```ruby
      # Foo.new.foo(1) #$ Integer, Integer
      # ```
      #
      # ### Diagnostic
      #
      # ```
      # test.rb:8:27: [error] Unexpected type arg is given to method type `[T] (T) -> T`
      # │ Diagnostic ID: Ruby::UnexpectedTypeArgument
      # │
      # └ Foo.new.foo(1) #$ Integer, Integer
      #                              ~~~~~~~
      # ```
      #
      %a{diagnostic-class} class UnexpectedTypeArgument < Base
        attr_reader type_arg: AST::Types::t

        attr_reader method_type: Interface::MethodType

        def node: () -> nil

        def initialize: (type_arg: AST::Types::t, method_type: Interface::MethodType, location: RBS::Location[untyped, untyped]) -> void

        def header_line: () -> String
      end

      # A type application needs more type arguments.
      #
      # ### RBS
      #
      # ```rbs
      # class Foo
      #   def foo: [T, S] (T, S) -> [T, S]
      # end
      # ```
      #
      # ### Ruby code
      #
      # ```ruby
      # Foo.new.foo(1, 2) #$ Integer
      # ```
      #
      # ### Diagnostic
      #
      # ```
      # test.rb:8:0: [error] Requires 2 types, but 1 given: `[T, S] (T, S) -> [T, S]`
      # │ Diagnostic ID: Ruby::InsufficientTypeArgument
      # │
      # └ Foo.new.foo(1, 2) #$ Integer
      #   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      # ```
      #
      %a{diagnostic-class} class InsufficientTypeArgument < Base
        attr_reader type_args: Array[AST::Types::t]

        attr_reader method_type: Interface::MethodType

        def initialize: (node: Parser::AST::Node, type_args: Array[AST::Types::t], method_type: Interface::MethodType) -> void

        def header_line: () -> String
      end

      # The type application doesn't satisfy generic constraints.
      #
      # ### RBS
      #
      # ```rbs
      # class Foo
      #   def foo: [T < Numeric] (T) -> T
      # end
      # ```
      #
      # ### Ruby code
      #
      # ```ruby
      # Foo.new.foo("") #$ String
      # ```
      #
      # ### Diagnostic
      #
      # ```
      # test.rb:7:19: [error] Cannot pass a type `::String` as a type parameter `T < ::Numeric`
      # │   ::String <: ::Numeric
      # │     ::Object <: ::Numeric
      # │       ::BasicObject <: ::Numeric
      # │
      # │ Diagnostic ID: Ruby::TypeArgumentMismatchError
      # │
      # └ Foo.new.foo("") #$ String
      #                      ~~~~~~
      # ```
      #
      %a{diagnostic-class} class TypeArgumentMismatchError < Base
        attr_reader type_argument: AST::Types::t

        attr_reader type_parameter: Interface::TypeParam

        attr_reader result: Subtyping::Result::Base

        include ResultPrinter

        def node: () -> nil

        def initialize: (type_arg: AST::Types::t, type_param: Interface::TypeParam, result: Subtyping::Result::Base, location: RBS::Location[untyped, untyped]) -> void

        def header_line: () -> String
      end

      # Type hint is given to a proc/lambda but it was ignored.
      #
      # 1. Because the hint is incompatible to `::Proc` type
      # 2. More than one *proc type* is included in the hint
      #
      # ### Ruby code
      #
      # ```ruby
      # # @type var proc: (^(::Integer) -> ::String) | (^(::String, ::String) -> ::Integer)
      # proc = -> (x) { x.to_s }
      # ```
      #
      # ### Diagnostic
      #
      # ```
      # test.rb:2:7: [error] The type hint given to the block is ignored: `(^(::Integer) -> ::String | ^(::String, ::String) -> ::Integer)`
      # │ Diagnostic ID: Ruby::ProcHintIgnored
      # │
      # └ proc = -> (x) { x.to_s }
      #          ~~~~~~~~~~~~~~~~~
      # ```
      #
      %a{diagnostic-class} class ProcHintIgnored < Base
        attr_reader hint_type: AST::Types::t

        def initialize: (hint_type: AST::Types::t, node: Parser::AST::Node) -> void
      end

      # RBS embedded in the Ruby code has validation error.
      #
      # ### Ruby code
      #
      # ```ruby
      # a = 1 #: Int
      # ```
      #
      # ### Diagnostic
      #
      # ```
      # test.rb:1:9: [error] Cannot find type `::Int`
      # │ Diagnostic ID: Ruby::RBSError
      # │
      # └ a = 1 #: Int
      #            ~~~
      # ```
      #
      %a{diagnostic-class} class RBSError < Base
        attr_reader error: Signature::Base

        def initialize: (error: Signature::Base, node: Parser::AST::Node, location: location) -> void
      end

      # `steep:ignore` comment is invalid.
      #
      # ### Ruby code
      #
      # ```ruby
      # # steep:ignore:start
      # ```
      #
      # ### Diagnostic
      #
      # ```
      # test.rb:1:0: [error] Invalid ignore comment
      # │ Diagnostic ID: Ruby::InvalidIgnoreComment
      # │
      # └ # steep:ignore:start
      #   ~~~~~~~~~~~~~~~~~~~~
      # ```
      #
      %a{diagnostic-class} class InvalidIgnoreComment < Base
        attr_reader comment: Parser::Source::Comment

        def initialize: (comment: Parser::Source::Comment) -> void
      end

      # Argument forwarding `...` cannot be done safely, because of:
      #
      # 1. The arguments are incompatible, or
      # 2. The blocks are incompatible
      #
      # ### RBS
      #
      # ```rbs
      # class Foo
      #   def foo: (*Integer) -> void
      #
      #   def bar: (*String) -> void
      # end
      # ```
      #
      # ### Ruby code
      #
      # ```ruby
      # class Foo
      #   def foo(*args)
      #   end
      #
      #   def bar(...)
      #     foo(...)
      #   end
      # end
      # ```
      #
      # ### Diagnostic
      #
      # ```
      # test.rb:8:8: [error] Cannot forward arguments to `foo`:
      # │   (*::Integer) <: (*::String)
      # │     ::String <: ::Integer
      # │       ::Object <: ::Integer
      # │
      # │ Diagnostic ID: Ruby::IncompatibleArgumentForwarding
      # │
      # └     foo(...)
      #           ~~~
      # ```
      #
      %a{diagnostic-class} class IncompatibleArgumentForwarding < Base
        attr_reader method_name: Symbol

        attr_reader params_pair: [Interface::Function::Params, Interface::Function::Params]?

        attr_reader block_pair: [Interface::Block?, Interface::Block?]?

        attr_reader result: Subtyping::Result::t

        include ResultPrinter2

        # One of `params_pair:` or `block_pair:` is specified where the first object is of the source method (`#foo`) and the second value is of the target method (`#bar`)
        #
        # ```ruby
        # def foo(...)
        #   bar(...)
        # end
        # ```
        #
        def initialize: (node: Parser::AST::Node, method_name: Symbol, params_pair: [Interface::Function::Params, Interface::Function::Params], result: Subtyping::Result::Base) -> void
                      | (node: Parser::AST::Node, method_name: Symbol, block_pair: [Interface::Block?, Interface::Block?], result: Subtyping::Result::Base) -> void

        def header_line: () -> String
      end

      # An empty array/hash has no type assertion.
      #
      # They are typed as `Array[untyped]` or `Hash[untyped, untyped]`,
      # which allows any element to be added.
      #
      # ```rb
      # a = []
      # b = {}
      #
      # a << 1
      # a << ""
      # ```
      #
      # Add type annotation to make your assumption explicit.
      #
      # ```rb
      # a = [] #: Array[Integer]
      # b = {} #: untyped
      #
      # a << 1
      # a << ""     # => Type error
      # ```
      #
      # ### Ruby code
      #
      # ```ruby
      # a = []
      # b = {}
      # ```
      #
      # ### Diagnostic
      #
      # ```
      # lib/test.rb:1:4: [error] Empty array doesn't have type annotation
      # │ Diagnostic ID: Ruby::UnannotatedEmptyCollection
      # │
      # └ a = []
      #       ~~
      #
      # lib/test.rb:2:4: [error] Empty hash doesn't have type annotation
      # │ Diagnostic ID: Ruby::UnannotatedEmptyCollection
      # │
      # └ b = {}
      #       ~~
      # ```
      #
      %a{diagnostic-class} class UnannotatedEmptyCollection < Base
        def header_line: () -> String
      end

      ALL: Array[singleton(Base)]

      type template = Hash[singleton(Base), LSPFormatter::severity?]

      self.@all_error: template?
      self.@default: template?
      self.@strict: template?
      self.@lenient: template?
      self.@silent: template?

      # This template reports everything as an error
      #
      def self.all_error: () -> template

      # This template detects inconsistencies between RBS and Ruby code APIs
      #
      def self.default: () -> template

      # This template helps you keeping your codebase (almost) type-safe
      #
      # You can start with this template to review the problems reported on the project,
      # and you can ignore some kind of errors.
      #
      def self.strict: () -> template

      # This template detects inconsistent definition in Ruby code with respect to your RBS definition
      #
      def self.lenient: () -> template

      # This template reports nothing
      #
      def self.silent: () -> template
    end
  end
end

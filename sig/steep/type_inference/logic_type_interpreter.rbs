module Steep
  module TypeInference
    class LogicTypeInterpreter
      attr_reader subtyping: Subtyping::Check

      attr_reader typing: Typing

      attr_reader factory (): AST::Types::Factory

      def initialize: (subtyping: Subtyping::Check, typing: Typing) -> void

      def eval: (env: TypeEnv, type: AST::Types::t, node: Parser::AST::Node) -> [TypeEnv, TypeEnv]

      def decompose_value: (Parser::AST::Node node) -> [Parser::AST::Node, Set[Symbol]]

      private

      def update_type_env: (Enumerable[Symbol] variables, truthy_type: AST::Types::t, falsy_type: AST::Types::t, truthy_env: TypeEnv, falsy_env: TypeEnv) -> [TypeEnv, TypeEnv]

      def guess_type_from_method: (Parser::AST::Node node) -> (AST::Types::Logic::ReceiverIsArg | AST::Types::Logic::ReceiverIsNil | AST::Types::Logic::Not | AST::Types::Logic::ArgIsReceiver | nil)

      # Decompose to given type to truthy and falsy types.
      #
      # This directly corresponds to case-when syntax with literals:
      #
      # ```ruby
      # case x
      # when nil       # value_node == {nil}, arg_type = type_of({x})
      #   ...
      # when 123       # value_node == {nil}, arg_type = type_of({x})
      #   ...
      # end
      # ```
      #
      def literal_var_type_case_select: (Parser::AST::Node value_node, AST::Types::t arg_type) -> [Array[AST::Types::t], Array[AST::Types::t]]

      def type_case_select: (AST::Types::t `type`, RBS::TypeName klass) -> [AST::Types::t, AST::Types::t]

      def type_case_select0: (AST::Types::t `type`, RBS::TypeName klass) -> [Array[AST::Types::t], Array[AST::Types::t]]
    end
  end
end

module Steep
  module Subtyping
    class Constraints
      class UnsatisfiedInvariantError < StandardError
        type reason = VariablesUnknownsNotDisjoint | VariablesFreeVariablesNotDisjoint | UnknownsFreeVariableNotDisjoint

        attr_reader constraints: Constraints

        attr_reader reason: reason

        def initialize: (reason: reason, constraints: Constraints) -> void

        class VariablesUnknownsNotDisjoint
          attr_reader vars: Array[Symbol]

          def initialize: (vars: Array[Symbol]) -> void

          def message: () -> ::String
        end

        class VariablesFreeVariablesNotDisjoint
          attr_reader var: Symbol

          attr_reader lower_bound: AST::Types::t?

          attr_reader upper_bound: AST::Types::t?

          def initialize: (var: Symbol, lower_bound: AST::Types::t?, upper_bound: AST::Types::t?) -> void

          def message: () -> ::String
        end

        class UnknownsFreeVariableNotDisjoint
          attr_reader var: Symbol

          attr_reader upper_bound: AST::Types::t?

          attr_reader lower_bound: AST::Types::t?

          def initialize: (var: Symbol, lower_bound: AST::Types::t?, upper_bound: AST::Types::t?) -> void

          def message: () -> ::String
        end
      end

      class UnsatisfiableConstraint < StandardError
        attr_reader var: Symbol

        attr_reader sub_type: AST::Types::t

        attr_reader super_type: AST::Types::t

        attr_reader result: Result::t

        def initialize: (var: Symbol, sub_type: AST::Types::t, super_type: AST::Types::t, result: Result::t) -> void
      end

      class Context
        attr_reader variance: VariableVariance

        attr_reader self_type: AST::Types::t

        attr_reader instance_type: AST::Types::t

        attr_reader class_type: AST::Types::t

        def initialize: (variance: VariableVariance, self_type: AST::Types::t, instance_type: AST::Types::t, class_type: AST::Types::t) -> void
      end

      attr_reader dictionary: Hash[Symbol, [Set[AST::Types::t], Set[AST::Types::t]]]

      attr_reader generics_upper_bounds: Hash[Symbol, AST::Types::t]

      def initialize: (unknowns: _Each[Symbol]) -> void

      def self.empty: () -> Constraints

      # Add a constraint on type variable
      #
      # Because the upperbound is truly a constraint which shouldn't include the result type, we have the flag.
      #
      def add: (Symbol var, ?sub_type: AST::Types::t?, ?super_type: AST::Types::t?) -> void

      # Add a constraint on type variable as a generics upper bound
      #
      def add_generics_upper_bound: (Symbol var, AST::Types::t type) -> void

      def eliminate_variable: (AST::Types::t `type`, to: AST::Types::t) -> AST::Types::t

      def unknown?: (Symbol var) -> bool

      def unknowns: () -> Set[Symbol]

      def unknown!: (Symbol var) -> void

      def empty?: () -> bool

      # Returns the upper bound of the variable
      #
      # If the variable is not constrained, it returns `top` type.
      #
      def upper_bound: (Symbol var) -> AST::Types::t

      # Returs the lower bound of the variable
      #
      # If the variable is not constrained, it returns `bot` type.
      #
      def lower_bound: (Symbol var) -> AST::Types::t

      def self.solve: (Constraints constraints, Check, Context) -> (Interface::Substitution | UnsatisfiableConstraint)

      def self.solve!: (Constraints constraints, Check, Context) -> Interface::Substitution

      def has_constraint?: (Symbol var) -> bool

      def each_unknown_variable: () { (Symbol) -> void } -> void
                               | () -> Enumerator[Symbol, void]

      # Yields a tuple of variable name, its lower bound, and its upper_bound
      #
      def each: () { ([Symbol, AST::Types::t, AST::Types::t]) -> void } -> void
              | () -> Enumerator[[Symbol, AST::Types::t, AST::Types::t], void]

      def to_s: () -> ::String

      # Returns a constraint for the variable
      #
      # If the variable is not constrained, it returns `nil`.
      # If the variable is constrained by one side, it returns the type.
      # If the variable is constrained by both sides, it returns a pair of types -- the lower bound and the upper bound.
      #
      def constraint: (Symbol var_name) -> (Array[Relation[AST::Types::t]] | AST::Types::t | nil)

      private

      def lower_bound_types: (Symbol var_name) -> Set[AST::Types::t]

      def upper_bound_types: (Symbol var_name) -> Set[AST::Types::t]
    end
  end
end

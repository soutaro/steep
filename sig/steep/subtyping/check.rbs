module Steep
  module Subtyping
    class Check
      attr_reader builder: Interface::Builder

      attr_reader cache: untyped

      attr_reader assumptions: untyped

      @bounds: Array[Hash[Symbol, AST::Types::t?]]

      def initialize: (builder: Interface::Builder) -> void

      def factory: () -> AST::Types::Factory

      def with_context: (self_type: untyped, instance_type: untyped, class_type: untyped, constraints: untyped) { () -> untyped } -> untyped

      def push_assumption: (untyped relation) { () -> untyped } -> untyped

      def push_variable_bounds: [A] (Array[Interface::TypeParam] | Hash[Symbol, AST::Types::t?] params) { () -> A } -> A

      def variable_upper_bound: (Symbol name) -> AST::Types::t?

      def variable_upper_bounds: () -> Hash[Symbol, AST::Types::t?]

      def self_type: () -> AST::Types::t

      def instance_type: () -> AST::Types::t

      def class_type: () -> AST::Types::t

      def constraints: () -> untyped

      def each_ancestor: (untyped ancestors) { (untyped) -> untyped } -> untyped

      def instance_super_types: (untyped type_name, args: untyped) -> untyped

      def singleton_super_types: (untyped type_name) -> untyped

      def check: (untyped relation, constraints: untyped, self_type: untyped, instance_type: untyped, class_type: untyped) -> untyped

      def check_type: (untyped relation) -> untyped

      def cache_bounds: (untyped relation) -> untyped

      def alias?: (untyped `type`) -> untyped

      def cacheable?: (untyped relation) -> untyped

      def true_type?: (untyped `type`) -> untyped

      def false_type?: (untyped `type`) -> untyped

      include Result::Helper

      def check_type0: (untyped relation) -> untyped

      def definition_for_type: (untyped `type`) -> untyped

      def arg_type?: (untyped `type`) -> untyped

      def check_type_arg: (untyped relation) -> untyped

      def same_type?: (untyped relation) -> (true | untyped)

      def check_interface: (Relation[Interface::Shape] relation) -> Result::t

      def check_method: (untyped name, untyped relation) -> untyped

      def check_type_application: (untyped result, untyped type_params, untyped type_args) { () -> untyped } -> untyped

      def check_generic_method_type: (untyped name, untyped relation) -> untyped

      def check_constraints: (untyped relation, variables: untyped, variance: untyped) -> untyped

      def check_method_type: (untyped name, untyped relation) -> untyped

      def check_block_given: (untyped name, untyped relation) { () -> untyped } -> untyped

      def check_function: (untyped name, untyped relation) -> untyped

      def check_method_params: (untyped name, untyped relation) -> untyped

      # ```rbs
      # (Symbol, Relation[MethodType]) -> (Array[[Symbol, Symbol]] | Result::t)
      # [A] (Symbol, Relation[MethodType]) { (Array[[Symbol, Symbol]]) -> A } -> (A | Result::t)
      # ````
      def match_method_type: (untyped name, untyped relation) { (untyped) -> untyped } -> untyped

      def match_params: (untyped name, untyped relation) -> untyped

      def expand_alias: (untyped `type`) { () -> untyped } -> untyped

      # Returns the shortest type paths for one of the _unknown_ type variables.
      # Returns nil if there is no path.
      def hole_path: (untyped `type`, ?untyped path) -> untyped
    end
  end
end

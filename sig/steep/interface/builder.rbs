use RBS::TypeName

module Steep
  module Interface
    class Builder
      class Config
        # Type of `self` type included immediately in the type expression
        #
        attr_reader self_type: AST::Types::t?

        # Type of `class` type included immediately in the type expression
        #
        attr_reader class_type: AST::Types::t?

        # Type of `instance` type included immediately in the type expression
        #
        attr_reader instance_type: AST::Types::t?

        # Upper bounds of type variables
        attr_reader variable_bounds: Hash[Symbol, AST::Types::t?]

        def initialize: (self_type: AST::Types::t?, variable_bounds: Hash[Symbol, AST::Types::t?]) -> void
                      | (self_type: AST::Types::t?, class_type: AST::Types::t, instance_type: AST::Types::t, variable_bounds: Hash[Symbol, AST::Types::t?]) -> void

        def subst: () -> Substitution?

        def self.empty: () -> Config

        def upper_bound: (Symbol) -> AST::Types::t?

        private

        def validate: () -> self

        def validate_fvs: (Symbol name, AST::Types::t?) -> void
      end

      attr_reader factory: AST::Types::Factory

      # # No type application (if generic), no self-instance-module resolution
      attr_reader object_shape_cache: Hash[TypeName, Shape?]

      attr_reader union_shape_cache: Hash[AST::Types::Union, Shape?]

      attr_reader singleton_shape_cache: Hash[TypeName, Shape?]

      def initialize: (AST::Types::Factory) -> void

      def fetch_cache: [KEY] (Hash[KEY, Shape?], KEY) { () -> Shape? } -> Shape?

      # Returns a shape of given type with respect to Config
      #
      # * If `self` occurs in the given type, it returns types with `self`
      # * If `self` doesn't occur in the given type, it returns type withohut `self`, that is resolved to `config.self_type`
      #
      def shape: (AST::Types::t, Config) -> Shape?

      # Returns a shape of given type with respect to Config
      #
      # The `self` types included in the returned Shape is the `self` type in the top level
      #
      # * `raw_shape(<self>)`        -> may return a shape with `self`
      # * `raw_shape(<Array[self]>)  -> returns a shape that returns `self` from `#first` method
      #
      def raw_shape: (AST::Types::t, Config) -> Shape?

      def self_shape: (AST::Types::t, Config) -> Shape?

      private

      def object_shape: (RBS::TypeName) -> Shape

      def singleton_shape: (RBS::TypeName) -> Shape

      def union_shape: (AST::Types::t, Array[Shape]) -> Shape?

      def intersection_shape: (AST::Types::t, Array[Shape]) -> Shape?

      def proc_shape: (AST::Types::Proc, Shape) -> Shape

      def tuple_shape: (AST::Types::Tuple) { (AST::Types::Name::Instance) -> Shape? } -> Shape?

      def record_shape: (AST::Types::Record) { (AST::Types::Name::Instance) -> Shape? } -> Shape?

      # Substitution for `self`/`instance`/`class` types, built from the name of given type
      #
      def class_subst: (AST::Types::Name::Instance | AST::Types::Name::Singleton) -> Substitution

      def interface_subst: (AST::Types::Name::Interface) -> Substitution

      # Substitution for type application of class instance, type alias, or interface types
      def app_subst: (AST::Types::Name::Instance | AST::Types::Name::Alias | AST::Types::Name::Interface) -> Substitution

      def method_name_for: (RBS::Definition::Method::TypeDef, Symbol name) -> method_name

      def replace_primitive_method: (method_name, RBS::Definition::Method::TypeDef, MethodType) -> MethodType

      # # Calculates the shape of given class, based on `public_only` and Config
      # #
      # # Returns `nil` if a type that cannot calculate Shape is given.
      # #
      # # * `public_only`: If false, returns a shape with private methods.
      # #
      # def shape: (AST::Types::t, public_only: bool, config: Config) -> Shape?

      # private

      @subtyping: Subtyping::Check?

      def subtyping: () -> Subtyping::Check

      # # Fetch and update cache
      # #
      # # Cache if given type is cacheable:
      # #
      # # * `self`, `instance`, `class` is not cacheable
      # # * Type variables are not cacheable
      # #
      # def fetch_cache: (AST::Types::t, bool public_only, Config) { () -> Shape? } -> Shape?

      # def include_self?: (AST::Types::t) -> bool

      # def definition_builder: () -> RBS::DefinitionBuilder

      # def object_shape: (
      #   AST::Types::Name::Instance | AST::Types::Name::Singleton | AST::Types::Name::Interface,
      #   bool public_only,
      #   boolish keep_self,
      #   boolish keep_instance,
      #   boolish keep_singleton
      # ) -> Shape

      # def raw_object_shape: (
      #   AST::Types::Name::Instance | AST::Types::Name::Singleton | AST::Types::Name::Interface,
      #   bool public_only,
      #   Substitution subst
      # ) -> Shape

      # def union_shape: (AST::Types::t, Array[Shape], bool public_only) -> Shape

      # def intersection_shape: (AST::Types::t, Array[Shape], bool public_only) -> Shape

      # def tuple_shape: (AST::Types::Tuple, bool public_only, Config) -> Shape

      # def record_shape: (AST::Types::Record, bool public_only, Config) -> Shape?

      # def proc_shape: (AST::Types::Proc, bool public_only, Config) -> Shape?


    end
  end
end

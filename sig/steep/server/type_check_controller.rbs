use LanguageServer::Protocol::Interface::Diagnostic as LSPDiagnostic
use Steep::Project::Target

module Steep
  module Server
    # TypeCheckController remembers changed files, keep track of open editors, and make a TypeCheckRequest that contains list of all files to be type checked
    #
    # ```rb
    # controller = TypeCheckController.new(project: project)
    #
    # controller.push_changes(file_path)           # Remember that the path is changed
    # controller.update_priority(open: file_path)  # Remember that an editor opens the path
    # controller.make_request(...)                 # Make an instance of TypeCheckRequest that contains list of all paths to type check
    # ```
    #
    class TypeCheckController
      # A type checking request keeps track of the progress of the type checking
      #
      # It has `path` of all files to be type checked and records which path is already checked.
      #
      class Request
        attr_reader guid: String

        attr_reader work_done_progress: WorkDoneProgress

        type target_and_path = [Symbol, Pathname]

        # The path of RBS files of libraries
        attr_reader library_paths: Set[target_and_path]

        # The path of signature files
        attr_reader signature_paths: Set[target_and_path]

        # The path of Ruby code files
        attr_reader code_paths: Set[target_and_path]

        # The path of files that is opened by the editor
        attr_reader priority_paths: Set[Pathname]

        # The path of files that are type checked already
        attr_reader checked_paths: Set[target_and_path]

        attr_reader started_at: Time

        # `true` to report the progress to the client
        attr_reader report_progress: bool

        # `true` to send a response to the client
        #
        # Defaults to `false`.
        #
        attr_accessor needs_response: bool

        def initialize: (guid: String, progress: WorkDoneProgress) -> void

        private def uri: (Pathname path) -> URI::File

        type target_path_string = [String, String]

        type json = { guid: String, library_uris: Array[target_path_string], signature_uris: Array[target_path_string], code_uris: Array[target_path_string], priority_uris: Array[String] }

        def as_json: (assignment: Services::PathAssignment) -> json

        def total: () -> Integer

        def percentage: () -> Integer

        # Enumerates all paths included in the request
        #
        def each_path: () { (Pathname) -> void } -> void
                     | () -> Enumerator[Pathname]

        def each_target_path: () { (target_and_path) -> void } -> void
                            | () -> Enumerator[target_and_path]

        def checking_path?: (target_and_path) -> bool

        # Mark a path is type checked
        def checked: (Pathname path, Target) -> void

        def finished?: () -> bool

        def each_unchecked_path: () { (Pathname) -> void } -> void
                               | () -> Enumerator[Pathname]

        def each_unchecked_target_path: () { (target_and_path) -> void } -> void
                                      | () -> Enumerator[target_and_path]

        def each_unchecked_code_target_path: () { (target_and_path) -> void } -> void
                                           | () -> Enumerator[target_and_path]

        def each_unchecked_library_target_path: () { (target_and_path) -> void } -> void
                                              | () -> Enumerator[target_and_path]

        def each_unchecked_signature_target_path: () { (target_and_path) -> void } -> void
                                                | () -> Enumerator[target_and_path]

        # Set `#report_progress` and return self, defaults to `true`
        #
        def report_progress!: (?bool) -> self

        # Merges another request into this request
        def merge!: (Request) -> self

        private def assigned_uris: (Services::PathAssignment, Set[target_and_path]) -> Array[target_path_string]
      end

      type typecheck_strategy = :cli | :interactive

      attr_reader project: Project

      attr_reader priority_paths: Set[Pathname]

      attr_reader changed_paths: Set[Pathname]

      attr_reader target_paths: Array[TargetPaths]

      attr_reader typecheck_strategy: typecheck_strategy

      # TargetPaths object keeps track of the expanded absolute paths of each target
      #
      # 1. *Library path* is a RBS file that is loaded as a part of a library
      # 2. *Signature path* is a RBS file that is loaded as a part of the application library
      # 3. *Code path* is a Ruby file that is being type checked
      #
      class TargetPaths
        attr_reader project: Project

        attr_reader target: Project::Target

        # Set of absolute paths of Ruby code
        #
        attr_reader code_paths: Set[Pathname]

        # Set of absolute paths of app signatures
        #
        attr_reader signature_paths: Set[Pathname]

        # Set of absolute paths of library signatures
        #
        # Unlike `code_paths` and `signature_paths`, the `library_paths` must be added explicitly not by `#add` method.
        #
        attr_reader library_paths: Set[Pathname]

        def initialize: (project: Project, target: Project::Target) -> void

        def all_paths: () -> Set[Pathname]

        def library_path?: (Pathname path) -> bool

        def signature_path?: (Pathname path) -> bool

        def code_path?: (Pathname path) -> bool

        # Adds `path` to the object
        #
        # Returns `false` if the path is not a part of the project.
        #
        # Whether `path` is a code path or signature path is automatically detected.
        # `library: true` is required to add the path to library path.
        #
        def add: (Pathname path, ?library: bool) -> bool

        alias << add

        def signature_path_changed?: (Set[Pathname]) -> bool

        def code_path_changed?: (Set[Pathname]) -> Set[Pathname]?
      end

      def initialize: (project: Project, strategy: typecheck_strategy) -> void

      def load: (command_line_args: Array[String]) { (Hash[String, ChangeBuffer::content]) -> void } -> void

      def push_changes: (Pathname path) -> void

      def update_priority: (open: Pathname) -> void
                         | (close: Pathname) -> void

      # Returns a TypeCheckRequest that contains all paths to be type checked
      #
      # This method also resets the controller status by removing everything from `changed_paths`.
      #
      # * If `include_unchanged` is `true`, all paths are included in the new request.
      # * `progress:` is a `WorkDoneProgress` object to report the progress of the type checking.
      #
      # Returns `nil` when no type checking is needed.
      #
      def make_request: (?guid: String, ?include_unchanged: bool, progress: WorkDoneProgress) -> Request?

      RBS_FLAG_NONE: 0
      RBS_FLAG_LIBRARY: 1
      RBS_FLAG_PROJECT: 2
      RBS_FLAG_TARGET_OPEN: 4
      RBS_FLAG_TARGET_CLOSE: 8

      RUBY_FLAG_NONE: 0
      RUBY_FLAG_TARGET_OPEN: 1
      RUBY_FLAG_TARGET_CLOSE: 2

      def load_target_rbs_files: (Request, TargetPaths, Integer rbs_flag) -> void

      def load_target_ruby_files: (Request, TargetPaths, Integer ruby_flag) -> void
    end
  end
end

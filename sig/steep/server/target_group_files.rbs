use Steep::Project::Target, Steep::Project::Group

module Steep
  module Server
    # TargetGroupFiles keeps track of the project files and their targets/groups
    #
    # ```rb
    # files = TargetGroupFiles.new(project)
    #
    # files.add_path(Pathname("lib/foo.rb"))
    # files.add_path(Pathname("lib/bar.rb"))
    # files.add_path(Pathname("sig/foo.rbs"))
    #
    # files.library_path?(path)
    # files.source_path_target(Pathname("lib/foo.rb"))
    # files.signature_path_target(Pathname("lib/bar.rb"))
    # files.inline_path_target(Pathname("sig/foo.rbs"))
    # ```
    #
    class TargetGroupFiles
      attr_reader project: Project

      attr_reader source_paths: PathEnumerator

      attr_reader signature_paths: PathEnumerator

      attr_reader inline_paths: PathEnumerator

      attr_reader library_paths: Hash[Symbol, Set[Pathname]]

      def initialize: (Project) -> void

      # Add project file path
      #
      # * Returns `true` if the path is under the control of the project.
      # * Returns `false` if the path doesn't belong to the project.
      #
      def add_path: (Pathname path) -> bool

      def add_library_path: (Target, *Pathname) -> void

      def each_library_path: (Target) { (Pathname) -> void } -> void
                           | (Target) -> Enumerator[Pathname]

      def library_path?: (Pathname) -> bool

      def []: (Pathname) -> (Target | Group | nil)

      def path_target: (Pathname) -> Target?

      def target_group_for_path: (Pathname) -> [Target, Group?]?

      def each_group_path: (Target | Group) { (Pathname) -> void } -> void
                         | (Target | Group) -> Enumerator[Pathname]

      def each_target_path: (Target, ?except: Group?) { (Pathname) -> void } -> void
                          | (Target, ?except: Group?) -> Enumerator[Pathname]

      class PathEnumerator
        attr_reader files: Hash[Pathname, Target | Group]

        def initialize: () -> void

        def empty?: () -> bool

        def []=: (Pathname, Target | Group) -> (Target | Group)

        def []: (Pathname) -> (Target | Group | nil)

        def paths: () -> Array[Pathname]

        def each: () { ([Pathname, Target, Group?]) -> void } -> void
                | () -> Enumerator[[Pathname, Target, Group?]]

        # Returns the target associated to the path
        def target: (Pathname) -> Target?

        # Returns a pair of target and group associated to the path
        def target_group: (Pathname) -> [Target, Group?]?

        # Yields all files from the collection
        #
        def each_project_path: (?except: Target?) { (Pathname) -> void } -> void
                            | (?except: Target?) -> Enumerator[Pathname]

        # Yields files that belongs to the target
        #
        # It also yields files that belongs to the sub-groups of the target.
        # When `except:` is given, files that belongs to the group are skipped.
        #
        def each_target_path: (Target, ?except: Group?) { (Pathname) -> void } -> void
                            | (Target, ?except: Group?) -> Enumerator[Pathname]

        # Yields files that belongs to the group or the target
        #
        # Files in the sub-groups of the target are skipped.
        #
        def each_group_path: (Target | Group) { (Pathname) -> void } -> void
                           | (Target | Group) -> Enumerator[Pathname]

        private def target_of: (Target | Group) -> Target

        private def group_of: (Target | Group) -> Group?
      end
    end
  end
end
